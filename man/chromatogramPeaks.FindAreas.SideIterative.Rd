% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MS_functional.R
\name{chromatogramPeaks.FindAreas.SideIterative}
\alias{chromatogramPeaks.FindAreas.SideIterative}
\title{chromatogramPeaks.FindAreas.SideIterative}
\usage{
chromatogramPeaks.FindAreas.SideIterative(
  peaks,
  trace,
  initialEdges = c(0.075, 0.15),
  auc = "trapezoid",
  absoluteArea = FALSE,
  subDivisions = 100,
  na.rm = FALSE,
  maxIterations = c(left = 25, right = 25),
  iterationCutOff = c(left = 0.001, right = 0.001),
  iterationChange = c(left = 0.1, right = 0.1),
  includeIterateCounts = FALSE,
  sides = c("left", "right"),
  orderDirection = list(left = c("left", "right"), right = c("right", "left")),
  maxLeftRight = NA
)
}
\arguments{
\item{peaks}{peak table with at least peak_rt for all peaks}

\item{trace}{data.frame (rt, intensity) of the chromatogram which has the peaks}

\item{initialEdges}{2-element numeric vector specifying the lower limit and the
upper limit for the peak area calculation (other function).  They're relative
numbers: peak_rt+edges til peak_rt$edges}

\item{auc}{specifies the method name for the interpolation. Options are:
"trapezoid", "step", "spline" & "linear"}

\item{absoluteArea}{A logical value that determines if negative areas should
be added to the total area under the curve.}

\item{subDivisions}{an integer telling how many subdivisions should be used for
integrate (for non-linear approximations). Ignored if method is not spline.}

\item{na.rm}{logical, indicating whether NA values should be stripped before
the computation proceeds. In this case only the complete.cases of x and y
will be used. Defaults is FALSE}

\item{maxIterations}{2 element named (left, right) integer vector: maximum
number of iterations per side}

\item{iterationCutOff}{2 element named (left, right) numeric vector (first
is for the left limit, second is for the right limit). Defines the amount
of change in area that is to be considered still relevant to continue
iterating (0.001 means an increase of 0.1\%)}

\item{iterationChange}{2 element named (left, right) numeric vector: amount
of change to use per iteration per side. The value for the left side will
be subtracted from the initial limit, the value for the right side will be
added to the initial limit}

\item{includeIterateCounts}{logical vector. If TRUE that the iteration counts
are included in the resulting peak. Default is FALSE. For debugging/testing
purposes}

\item{sides}{2 element character vector which defines the order of adjustment
of the sides. Default is c("left","right")}

\item{orderDirection}{a 2 named (left, right) element list of 2 element
character vectors which specify for each side the order or adjustment.}

\item{maxLeftRight}{default is NA, if not NA, then a two-element numeric
vector is expected where the first one is the maximum distance between the
left (rt) value and the peak maximum and the second one is the maximum
distance between the right (rt) value and the peak maximum}
}
\value{
the peak table data.frame with extra columns containing the new (area
related) info.
}
\description{
Calculates the peak areas on the basis of peak_rt, the left &
right (rt) cutoff and the trace (chromatogram) itself, but also attempts to
change the retention time limits in a structured manner. This is done to
adjust for unusual peak shapes (tailing, fronting, etc)
}
\note{
Both the left and the right limits of the peak are adjusted; each side
gets adjusted in both directions (first left, then right for left limit/
first right, then left for the right limit)

gives variable result with complex chromatograms with peaks close together
or even overlapping
}
\examples{

demoFile <- fs::path_package("extdata", "Data0001.CSV", package = "MS.Analysis")
result <- readLines(demoFile, n = 9092)
result <- read.table(text = result, sep = ",", header = FALSE)[, 2:3]
colnames(result) <- c("rt", "intensity")
result |> head()
plot(result, type = "l")
peaks <- data.frame(
  peak_rt = c(11.074, 12.133, 17.769, 19.515),
  peak_intensity = c(145412448, 151731744, 99109632, 70294472),
  left = NA,
  right = NA,
  area = NA
)
peaks <- chromatogramPeaks.FindAreas.SideIterative(
  peaks = peaks,
  trace = result,
  includeIterateCounts = TRUE,
  initialEdges = c(0.1, 0.1),
  iterationCutOff = c(left = 0.01, right = 0.01),
  iterationChange = c(left = 0.01, right = 0.01),
)
peaks
plot(result, type = "l", xlim = c(10, 21), ylim = c(0, 2E8))
text(
  peaks$peak_rt,
  peaks$peak_intensity,
  formatMinimumDigits(1)(peaks$peak_rt),
  cex = 0.65,
  pos = 3,
  col = "red"
)
abline(
  v = peaks$peak_rt,
  col = scales::alpha(rgb(1, 0, 0), 0.75),
  lty = "dotted"
)
abline(
  v = peaks$left,
  col = scales::alpha(rgb(0, 0, 1), 0.75),
  lty = "dashed"
)
abline(
  v = peaks$right,
  col = scales::alpha(rgb(0, 0, 1), 0.75),
  lty = "dashed"
)

}
