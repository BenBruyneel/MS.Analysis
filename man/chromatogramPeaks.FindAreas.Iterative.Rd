% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MS_functional.R
\name{chromatogramPeaks.FindAreas.Iterative}
\alias{chromatogramPeaks.FindAreas.Iterative}
\title{chromatogramFindAreas.Iterative}
\usage{
chromatogramPeaks.FindAreas.Iterative(
  peaks,
  trace,
  initialEdges = c(0.075, 0.15),
  auc = "trapezoid",
  absoluteArea = FALSE,
  subDivisions = 100,
  na.rm = FALSE,
  maxIterations = c(10L, 10L),
  iterationCutOff = c(0.05, 0.05),
  change = c(0.1, 0.1),
  includeIterateCounts = FALSE,
  maxLeftRight = NA
)
}
\arguments{
\item{peaks}{peak table with at least peak_rt for all peaks}

\item{trace}{data.frame (rt, intensity) of the chromatogram which has the peaks}

\item{initialEdges}{2-element numeric vector specifying the lower limit and the
upper limit for the peak area calculation (other function).  They're relative
numbers: peak_rt+edges til peak_rt$edges}

\item{auc}{specifies the method name for the interpolation. Options are:
"trapezoid", "step", "spline" & "linear"}

\item{absoluteArea}{A logical value that determines if negative areas should
be added to the total area under the curve.}

\item{subDivisions}{an integer telling how many subdivisions should be used for
integrate (for non-linear approximations). Ignored if method is not spline.}

\item{na.rm}{logical, indicating whether NA values should be stripped before
the computation proceeds. In this case only the complete.cases of x and y
will be used. Defaults is FALSE}

\item{maxIterations}{2 element integer vector: maximum number of iterations
per side}

\item{iterationCutOff}{2 elements numeric vector (first is for the left limit,
second is for the right limit). Defines the amount of change in area that is
to be considered still relevant to continue iterating (0.05 means an increase
of 5\%)}

\item{change}{2 element numeric vector: amount of change to use per iteration
per side. The value for the left side will be subtracted from the initial
limit, the value for the right side will be added to the initial limit}

\item{includeIterateCounts}{logical vector. If TRUE that the iteration counts
are included in the resulting peak. Default is FALSE. For debugging/testing
purposes}

\item{maxLeftRight}{default is NA, if not NA, then a two-element numeric
vector is expected where the first one is the maximum distance between the
left (rt) value and the peak maximum and the second one is the maximum
distance between the right (rt) value and the peak maximum}
}
\value{
the peak table data.frame with extra columns containing the new (area
related) info.
}
\description{
Calculates the peak areas on the basis of peak_rt, the left &
right (rt) cutoff and the trace (chromatogram) itself, but also attempts to
change the retention time limits in a structured manner. This is done to
adjust for unusual peak shapes (tailing, fronting, etc)
}
\note{
The left limit of the peak is adjusted first, after that the right limit

gives variable result with complex chromatograms with peaks close together
or even overlapping
}
\examples{

demoFile <- fs::path_package("extdata", "Data0001.CSV", package = "MS.Analysis")
result <- readLines(demoFile, n = 9092)
result <- read.table(text = result, sep = ",", header = FALSE)[, 2:3]
colnames(result) <- c("rt", "intensity")
result |> head()
plot(result, type = "l")
peaks <- data.frame(
  peak_rt = c(11.074, 12.133, 17.769, 19.515),
  peak_intensity = c(145412448, 151731744, 99109632, 70294472),
  left = NA,
  right = NA,
  area = NA
)
peaks <- chromatogramPeaks.FindAreas.Iterative(
  peaks = peaks,
  trace = result,
  initialEdges = c(0.1,0.1),
  change = c(0.02, 0.02),
  includeIterateCounts = TRUE
)
peaks
plot(result, type = "l", xlim = c(10, 21), ylim = c(0, 2E8))
text(
  peaks$peak_rt,
  peaks$peak_intensity,
  formatMinimumDigits(1)(peaks$peak_rt),
  cex = 0.65,
  pos = 3,
  col = "red"
)
abline(
  v = peaks$peak_rt,
  col = scales::alpha(rgb(1, 0, 0), 0.75),
  lty = "dotted"
)
abline(
  v = peaks$left,
  col = scales::alpha(rgb(0, 0, 1), 0.75),
  lty = "dashed"
)
abline(
  v = peaks$right,
  col = scales::alpha(rgb(0, 0, 1), 0.75),
  lty = "dashed"
)

}
